11장. 합성과 유연한 설계
=====
강의자의 강의 인트로(?)입니다.  
* 11장에서 합성과 믹스인을 말하는 이유도 앞으로 펼쳐질 포인터의 포인터 연산이 언어문법으로 어떻게 제공되는지를 이해시키는 기반이 됩니다.
* 11장은 상속의 조합 폭발과 합성을 가르친다기보다는 그저 데코레이터 패턴을 가르치는 장에 가깝습니다.
- - -
## 목차
1. [참고](#참고)
	* [관련자료](#관련자료)
	* [책의 목차](#책의-목차)
2. [요약](#요약)
	* [객체지향의 본질](#객체지향의-본질)
	* [상속과 확장](#상속과-확장)
	* [나쁜 확장과 좋은 확장](#나쁜-확장과-좋은-확장)
	* 27:30 / 1:02:00

## 참고
### 관련자료
* [유투브 강의](https://www.youtube.com/watch?v=vSnFC2x-RYE)
* [강의 교안](https://github.com/nara1030/portfolio/blob/master/docs/lecture_list/code_spitz_object2/reference/84_1.pdf)
* [오브젝트 요약정리](https://github.com/nara1030/portfolio/blob/master/docs/book/object.md)

### 책의 목차
* 상속을 합성으로 변경하기
	* 불필요한 인터페이스 상속문제:
		* java.util.Properties와 java.util.Stack
		* 메서드 오버라이딩의 오작용 문제: InstrumentedHashSet
		* 부모 클래스와 자식 클래스의 동시 수정 문제: PersonalPlaylist
* 상속으로 인한 조합의 폭발적인 증가
	* 기본 정책과 부가 정책 조합하기
	* 상속을 이용해서 기본 정책 구현하기
	* 기본 정책에 세금 정책 조합하기
	* 기본 정책에 기본 요금 할인 정책 조합하기
	* 중복 코드의 덫에 걸리다
* 합성 관계로 변경하기
	* 기본 정책 합성하기
	* 부가 정책 적용하기
	* 기본 정책과 부가 정책 합성하기
	* 새로운 정책 추가하기
	* 객체 합성이 클래스 상속보다 더 좋은 방법이다
* 믹스인
	* 기본 정책 구현하기
	* 트레이트로 부가 정책 구현하기
	* 부가 정책 트레이트 믹스인하기
	* 쌓을 수 있는 변경

##### [목차로 이동](#목차)

## 요약
### 객체지향의 본질
오브젝트2(코드스피츠84) 첫 강의다. 이 책은 일반적인 객체지향 도서와 비교해 순서가 역전되어 있다.

* 선: 객체지향 사고
* 후: 객체지향이 어떤 식으로 동작하는가(내부적 동작)

오브젝트2는 `내부적 동작`을 다루는 첫 강의다. 자바 다형성 구현의 핵심인 `lazy binding`에서 시작해본다.

| 외부 | 내부 |
| :--: | :--: |
| 키워드 | 포인터의 포인터 |

즉, 다형성은 코드 수준에선 `키워드`로 구현하지만 내부적으로는 `2중 혹은 3중 포인터`라는 것이다. 기본적으로는 메모리에 올라가면 `링크드리스트` 이상도 이하도 아니다.

##### [목차로 이동](#목차)

### 상속과 확장
객체지향 언어 중 상속(`inherit`)이 있는 유일한 언어가 자바다. 타 언어에서는 `inherit`가 아닌 확장, 즉 `extend`가 사용된다. 상속이 확장의 한 종류라고 할 수 있으니, ~~개인적으로~~ 상속을 통해 올바른 확장을 하는 방법을 다룬다고 이해했다.

우선 현실 세계를 예로 정성적인 느낌을 한 번 살펴보면, `확장`은 `자동차에게 날개를 다는 것`이 아니다(~~구분이 어렵긴 하지만~~). 더해, 프로그래밍 세계에서는 `오버로딩` 혹은 `오버라이딩` 같은 개념들도 확장이라고 할 수 있다. 즉 `확장`이라는 개념이 단지 늘리는 것만을 얘기하지 않는다는 것이다. 그렇다면 프로그래밍에서 확장을 위한 규칙은 무엇일까?

* 유산을 물려받지 않을 것
	* `super` 및 `protected` 금지
	* 단, `public`은 인터페이스의 개념이지 유산(부모-자식간 해당)과는 관계 없음
* 대리 역할을 하지 않을 것
	* `override` 금지
	* 단지 type만 같을 뿐, 기능하지 않음

즉, 프로그래밍 세계에서 `좋은 확장`이란 `확장하는 쪽이 부분 책임만 지는 것`이다.

##### [목차로 이동](#목차)

### 나쁜 확장과 좋은 확장
* 나쁜 확장
	* `super` 사용
		* 어떤 문제(부모)가 다른 문제(자식)의 부분 집합이라는 사고 전제(변화에 대응 힘듦)
	* `override` 사용
		* 미묘한 컨텍스트(부모) 제대로 반영해서 재정의 메소드 생성 힘듦(도메인 지식 필요)
		* 나(부모)의 의미는 내 주변이 정의한다는 것이 컨텍스트 이해를 힘들게 함

* 좋은 확장
	* `super` 배제 → 이걸 강제한 것이 `interface`
		* 부모의 모든 메소드를 `final`, `private`, `abstract protected`로 선언(즉, 자식이 사용하지 못하게 만듦)
			* `abstract protected`는 다시 말해, 부모에 동작 혹은 컨텍스트가 없음을 의미
			* 이는 부모가 `타입`으로만 작동할 뿐 `기능`하진 않음을 의미
		* 부모의 생성자는 인자를 받지 않음(`??`)
			* 상속받은 자식이 부모 생성자를 호출하는 것을 방지(의존성 제거)
	* `override` 배제
		* 부모의 모든 메소드를 `final`, `private`, `abstract protected`로 선언

모던 랭기지는 좋은 확장의 규칙을 문법에 내장하고 있다. 예를 들면 코틀린은 모든 메소드의 디폴트 선언이 `public final`이다.

이 규칙을 지킬 수 없으면 상속을 포기하고 합성을 사용해야 한다. 단 [지난 강의]에 언급했듯, 규칙을 지켜서 상속을 사용하더라도 `클래스 조합 폭발`(`템플릿 메소드 패턴`과 `전략 패턴`의 차이)은 피할 수 없다. 따라서 조합 폭발이 일어나지 않는 경우의 수가 한정되어 있는 케이스에만 상속으로 구현하는 것이 좋다.
		
##### [목차로 이동](#목차)

### .

##### [목차로 이동](#목차)