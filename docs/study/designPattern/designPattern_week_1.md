1주차 - Strategy Pattern
=======
2019.09.21: 스트레티지 패턴, 즉 전략패턴
- - - -
## 목차
1. [예제](#예제)
	* [초기버전](#초기버전)
	* [상속](#상속)
	* [구현](#구현) 
	* [캡슐화로 유연성 향상](#캡슐화로-유연성-향상)
		* [바뀌는 부분 분리하기](#바뀌는-부분-분리하기)
2. [확장](#확장)
	* super 금지
	* 디자인 패턴이란
3. [참고](#참고)

## 예제
### 초기버전
아래는 `오리 연못 시뮬레이션 게임`의 초기 버전이다.

<img src="./img/duck_hierarhcy_1.png" width="600" height="300"></br>

수퍼 클래스(추상 클래스)에서 오리의 필수 행동(`quack()`, `swim()`)을 구현(`display()` 제외)한 후 이를 자식 클래스(구상 클래스)에서 재사용 혹은 오버라이딩해서 사용한다.

##### [목차로 이동](#목차)

### 상속
`오리들이 날아다닐 수 있도록 해`라는 요청사항(변경사항)이 들어왔다. 이 요청에 대해 부모 클래스에 `fly()` 메소드를 정의함으로써 하위 클래스가 그것을 상속받도록 설계할 수 있다.

<img src="./img/duck_hierarhcy_2.png" width="600" height="400"></br>

하지만 이 경우 `모든 서브 클래스가 날 수 있는 것은 아니다`라는 문제가 있다. 즉, 이렇게 설계한다면 일부 서브 클래스에 적합하지 않은 행동이 추가된 것이다. 물론 `아무 것도 하지 않도록 오버라이드하면 되지 않느냐` 반론이 가능하다(`quack() 메소드에서 이미 그랬던 것처럼`). 하지만 상속을 이용한 설계에는 아래와 같은 단점이 존재할 수 있다.

* 서브 클래스에서 코드가 중복된다.
* 실행시에 특징을 바꾸기 힘들다.
	* 컴파일 타임에 행동이 특정된다.
	* 특정 구현을 써야만 했기 때문에 코드를 더 작성하는 것 외에는 행동을 변경할 여지가 없다.
* 모든 오리의 행동을 알기 힘들다.
	* 위의 `fly()` 메소드처럼 부모 클래스를 통해 구체 클래스를 특정할 수 없다.
* 코드를 변경했을 때 다른 오리들한테 원치 않은 영향을 끼칠 수 있다.

##### [목차로 이동](#목차)

### 구현
상속의 경우, 변경사항이 생길 때마다 Duck의 서브 클래스의 `fly()`와 `quack()` 메소드를 일일이 살펴봐야 하고, 상황에 따라 오버라이드해야 한다.

결국 (전체가 아닌) 일부 형식의 오리만 날거나 꽥꽥거릴 수 있도록 하는 더 깔끔한 방법을 찾아야 한다.

<img src="./img/duck_hierarhcy_3.png" width="600" height="400"></br>

하지만 이 경우도 역시 코드 중복이라는 단점이 존재한다. 고무 오리가 날아다니는 것과 같은 이상한 일은 방지할 수 있지만 코드의 재사용을 전혀 기대할 수 없게 된다.

##### [목차로 이동](#목차)

### 캡슐화로 유연성 향상
소프트웨어 개발에 있어서 절대로 바뀌지 않는 것이 뭘까? 바로 변화이다. 바로 이 상황에서 어울리는 디자인 원칙이 있다.

> 애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분으로부터 분리시킨다.

이는 다시 말해, 바뀌는 부분은 따로 뽑아서 캡슐화시키는 것이다. 그렇게 하면 나중에 바뀌지 않는 부분에는 영향을 미치지 않은 채로 그 부분만 고치거나 확장할 수 있다.

곁가지긴 하지만 `캡슐화 ≠ 정보은닉`라고 생각이 든다. 캡슐화는 코드를 변경하는 과정에서 의도하지 않은 일이 일어나는 것을 줄이면서 시스템의 유연성은 향상시킬 수 있게 한다.

##### [목차로 이동](#목차)

#### 바뀌는 부분 분리하기
지금까지 살펴본 바로는, `fly()`와 `quack()` 문제를 제외하면 Duck 클래스는 잘 작동하고 있으며, 나머지 부분은 자주 달라지거나 바뀌지 않는다. 즉 `fly()`와 `quack()`은 Duck 클래스에서 오리마다 달라지는 부분이다. 이러한 행동을 Duck 클래스로부터 갈라내기 위해서 그 두 메소드를 모두 Duck 클래스로부터 끄집어내서 각 행동을 나타낼 클래스 집합을 새로 만들도록 한다.

그렇다면 `나는 행동`과 `꽥꽥거리는 행동`을 구현하는 클래스 집합을 어떻게 디자인해야 할까? 두 가지 고려사항이 있다.

* 최대한 유연하게 만들어야 함(`캡슐화`)
	* 인터페이스(상위 형식) 사용
* Duck의 인스턴스에 행동을 할당할 수 있어야 함
	* 초기화
	* 프로그램 실행 중 변경(`setter 메소드`)

<img src="./img/duck_hierarhcy_4.jpg" width="600" height="250"></br>

`나는 행동`과 `꽥꽥거리는 행동`은 이제 Duck 클래스에서 구현하지 않는다. 대신 특정 행동만을 목적으로 하는 클래스의 집합을 만들도록 한다. 이 방법은 지금까지 썼던, 행동을 Duck 클래스에서 구체적으로 구현하거나 서브 클래스 자체에서 별도로 구현하는 방법하고는 상반된 방법이다(특정 구현을 써야만 했기 때문에 코드를 더 작성하는 것 외에는 행동을 변경할 여지가 없었음).

새로운 디자인을 사용하면 Duck의 서브 클래스에서는 인터페이스(`FlyBehavior`나 `QuackBehavior`)로 표현되는 행동을 사용하게 된다.

<img src="./img/duck_hierarhcy_5.jpg" width="700" height="500"></br>

위에서 `"인터페이스에 맞춰서 프로그래밍한다"`는 것은 사실 `"상위 형식에 맞춰서 프로그래밍한다"`는 것을 뜻한다. 즉 자바의 인터페이스를 사용하라는 것이 아니라 실제 실행 시에 쓰이는 객체가 코드에 의해서 고정되지 않도록 어떤 상위 형식(supertype)에 맞춰서 프로그래밍함으로써 다형성을 활용해야 한다는 것이다.

이러한 예로 **변수를 선언할 때는 보통 추상 클래스나 인터페이스 같은 상위 형식으로 선언**해야 한다는 말이 있다.

* 설계  
	<img src="./img/duck_hierarhcy_6.jpg" width="400" height="350"></br>
* 코드
	* X  
		```java
		Dog d = new Dog();
		d.bark();
		```
		* 변수 d를 Dog 형식으로 선언하면 구체적인 구현에 맞춰서 코딩해야 함
	* △  
		```java
		Animal animal = new Dog();
		animal.makeSound();
		```
		* Dog라는 것을 알고 있지만 다형성을 활용하여 Animal에 대한 레퍼런스 사용
	* O  
		```java
		a = getAnimal();
		a.makeSound();
		```
		* 위처럼 초기화시 직접 코드로 인스턴스를 만드는(`new Dog()와 같은 식으로`) 대신 구체적으로 구현된 객체를 실행 시에 대입하는 것이 좋음
		* Animal의 하위 형식 가운데 어떤 형식인지는 모르나, `makeSound()`에 대해 올바른 반응을 할 수만 있으면 됨

실제 보이는 간단한 예는 아래와 같다.

```java
List<String> list = new ArrayList<>();
```
		
##### [목차로 이동](#목차)

## 확장

##### [목차로 이동](#목차)

## 참고

##### [목차로 이동](#목차)